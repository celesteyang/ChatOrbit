name: CI

on:
  push:
    branches: ["main"]
  pull_request:

jobs:
  # go-build:
  #   name: Go Build
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     - name: Set up Go
  #       uses: actions/setup-go@v5
  #       with:
  #         go-version: '1.24.x'

  #     - name: Cache Go modules
  #       uses: actions/cache@v4
  #       with:
  #         path: |
  #           ~/go/pkg/mod
  #           ~/.cache/go-build
  #         key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
  #         restore-keys: |
  #           ${{ runner.os }}-go-

  #     - name: Download dependencies
  #       run: go mod download

  # integration-tests:
  #   name: Integration Tests
  #   runs-on: ubuntu-latest
  #   needs: go-build
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4

  #     - name: Set up Python
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: '3.11'
  #         cache: 'pip'
  #         cache-dependency-path: requirements.txt

  #     - name: Install Python dependencies
  #       run: pip install -r requirements.txt

  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3

  #     - name: Build and start services
  #       run: docker compose -f docker-compose.services.yaml up --build -d

  #     - name: Wait for services to become ready
  #       run: |
  #         python - <<'PY'
  #         import socket, time, sys

  #         ports = [8089, 8088, 8087]
  #         deadline = time.time() + 180

  #         def port_ready(port: int) -> bool:
  #           try:
  #             with socket.create_connection(("localhost", port), timeout=3):
  #               return True
  #           except OSError:
  #             return False

  #         while time.time() < deadline:
  #           if all(port_ready(p) for p in ports):
  #             sys.exit(0)
  #           time.sleep(3)

  #         sys.exit("Services did not become ready in time")
  #         PY

  #     - name: Run integration tests
  #       working-directory: ./tests/integration
  #       run: pytest -s

  #     - name: Show service logs on failure
  #       if: failure()
  #       run: docker compose -f docker-compose.services.yaml logs

  #     - name: Stop services
  #       if: always()
  #       run: docker compose -f docker-compose.services.yaml down --volumes --remove-orphans

  deploy:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    # needs: integration-tests  # only run if tests pass
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and Push Auth service
        uses: docker/build-push-action@v5
        with:
          context: ./services/auth
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/auth:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/auth:${{ github.sha }}

      - name: Build and Push Chat service
        uses: docker/build-push-action@v5
        with:
          context: ./services/chat
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/chat:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/chat:${{ github.sha }}

      - name: Build and Push User service
        uses: docker/build-push-action@v5
        with:
          context: ./services/user
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/user:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/user:${{ github.sha }}
